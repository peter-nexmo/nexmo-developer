<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/media.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/media.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Nexmo Client SDK
 *  Media Object Model
 *
 * Copyright (c) Nexmo Inc. 2017-2018
 */

const ConversationClientError = require('../conversationClientError');
const RtcHelper = require('./rtc_helper');
const TraceWS = require('./rtcstats/trace-ws');
const RTCStats = require('./rtcstats/rtcstats');
const logger = require('loglevel');
const Utils = require('../utils');

const NexmoApiError = ConversationClientError.NexmoApiError;
const NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * WebRTC Media class
 * @class Media
 * @property {Application} application The parent application object
 * @property {Conversation} parentConversation the conversation object this media instance belongs to
 * @property {Member[]} parentConversation.remoteMembers The remote members
 * @property {number} parentConversation.streamIndex the latest index of the streams, updated in each new peer offer
 * @property {object[]} rtcObjects data related to the rtc connection
 * @property {string} rtcObjects.rtc_id the rtc_id
 * @property {PeerConnection} rtcObjects.pc the current PeerConnection object
 * @property {Stream} rtcObjects.localStream the stream of the specific rtc_id
 * @property {string} rtcObjects.type=video|screenshare the type of the stream
 * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)
 * @property {Promise[]} rtcNewPromises an array that contains all the promises of the rtc:new requests
 * @emits Application#rtcstats:report
 * @emits Member#media:stream:on
 */

/**
 * Member listening for audio stream on.
 *
 * @event Member#media:stream:on
 *
 * @property {number} payload.streamIndex the index number of this stream
 * @property {number} [payload.rtc_id] the rtc_id / leg_id
 * @property {string} [payload.remote_member_id] the id of the Member the stream belongs to
 * @property {string} [payload.name] the stream's display name
 * @property {MediaStream} payload.stream the stream that is activated
 * @property {boolean} [payload.video_mute] if the video is hidden
 * @property {boolean} [payload.audio_mute] if the audio is muted
 */

class Media {
    constructor(conversation) {
        this.log = logger.getLogger(this.constructor.name);
        if (conversation) {
            this.rtcHelper = new RtcHelper();
            this.application = conversation.application;
            this.application.activeStream = this.application.activeStream || {}; // keep the activeStreams in case of transfer
            this.application.activeStreams = this.application.activeStreams || [];
            this._eventsQueue = [];
            this.parentConversation = conversation;
            this.parentConversation.remoteMembers = [];
            this.rtcObjects = {};
            this.rtcNewPromises = [];
            this.streamIndex = 0;
            this.rtcstats = {};
            this.rtcStats_module = null;
            if (this.application.session.config &amp;&amp; this.application.session.config.rtcstats) {
                this.rtcstats = {
                    emit_events: this.application.session.config.rtcstats.emit_events,
                    ws_url: this.application.session.config.rtcstats.ws_url
                }
            }
            if (this.application.session.config &amp;&amp; this.application.session.config.screenShareExtensionId &amp;&amp; this.application.session.config.screenShareExtensionId !== '') {
                this.rtcHelper._setScreenShareExtensionId(this.application.session.config.screenShareExtensionId);
            }
            if (this.rtcstats.emit_events) {
                this._initStatsReporting();
            }
        } else {
            this.log.warn('No conversation object in Media');
        }
    }

    _attachEndingEventHandlers() {
        this.log.debug('attaching leave listeners in media for ' + this.parentConversation.id)
        this.parentConversation.on('rtc:terminate', 'media_module', (event) => {
            this._handleParticipantRtcTerminate(event);
        })
        this.parentConversation.on('member:left', 'media_module', (member) => {
            this._handleMemberLeft(member);
            if ((!member.transferred_to || member.transferred_from) &amp;&amp; member.user.id === this.application.me.id &amp;&amp; this.application.activeStream) {
                this.disable();
            }
        })
    }

	/**
	 * Application listening for RTC stats.
	 *
	 * @event Application#rtcstats:report
	 *
	 * @property {number} MOS - the calculated MOS score
	 * @property {Object} report - the stats report from WebRTC | when the call has ended this is null, see the mos_report for final MOS summary
	 * @property {Conversation} Conversation - the conversation the report belongs to
	 * @property {Object} mos_report - a report for the MOS values
	 * @property {string} mos_report.min - the minimum MOS value during the stream
	 * @property {string} mos_report.max - the maximum MOS value during the stream
	 * @property {string} mos_report.last - the last MOS value during the stream
	 * @property {string} mos_report.average - the average MOS value during the stream
	 *
	 * @example &lt;caption>listening for quality mos score&lt;/caption>
	 *  application.on("rtcstats:report",(mos, report, conversation, mos_report) => {
	 *              console.log("call quality (MOS)", mos);
     *              if (mos_report) {
     *              console.log('mos_report', mos_report);
     *               }
	 *           });
	 */
    _enableCallStats(pc) {
        this.application.session.callstats.addNewFabric(pc, this.parentConversation.me.id, "audio", this.parentConversation.id);
    }

    /**
     * Switch on the rtcStat reporting to the websocket connection and events
     * @param ws_url
     * @private
     */
    _enableStatsReporting(ws_url) {
        this.application.session.config.rtcstats.ws_url = ws_url;
        this.rtcstats.ws_url = ws_url;
        this._initStatsReporting();
    }

    /**
     * Switch on the rtc stats emit events
     * @private
     */
    _enableStatsEvents() {
        this.application.session.config.rtcstats.emit_events = true;
        this.rtcstats.emit_events = true;
        this._initStatsEvents();
    }

    _initStatsReporting() {
        if (!this.rtcHelper.isNode() &amp;&amp; !this.rtcStats_module &amp;&amp; this.application.session.config.rtcstats.ws_url) {
            this.rtcStats_wsConnection = new TraceWS();
            this.rtcStats_module = new RTCStats(
                this.rtcStats_wsConnection.trace,
                false,// isCallback
                1000, // interval at which getStats will be polled,
                [''] // RTCPeerConnection prefixes to wrap.
            );
            this.rtcStats_wsConnection.init({
                rtcstatsUri: this.application.session.config.rtcstats.ws_url
            });
        }
    }

    _initStatsEvents() {
        if (!this.rtcHelper.isNode() &amp;&amp; !this.rtcStats_module) {
            const emit_event = (type, mos, report, mos_report) => {
                if (type === 'mos') {
                    if (mos) {
                        this.application.emit('rtcstats:report', mos, report, this.parentConversation);
                    }
                } else if (type === 'mos_report') {
                    this.application.emit('rtcstats:report', mos, null, this.parentConversation, mos_report);
                }
            }
            this.rtcStats_module = new RTCStats(
                emit_event,
                true, // isCallback
                1000, // interval at which getStats will be polled,
                [''] // RTCPeerConnection prefixes to wrap.
            );
        }
    }

    /**
     * Switch off the rtcStat reporting
     * @private
     */
    _disableStatsReporting() {
        this.application.session.config.rtcstats.ws_url = '';
        this.rtcstats.ws_url = '';
        this.this.rtcStats_wsConnection.disable();
        delete this.rtcStats_module;
    }

    /**
     * Switch off the rtcStat events
     * @private
     */
    _disableStatsEvents() {
        this.application.session.config.rtcstats.emit_events = false;
        this.rtcstats.emit_events = false;
        this.rtcStats.disable();
        delete this.rtcStats_module;
    }

	/**
	 * Handles the enabling of audio only stream with rtc:new
	 * @private
	 */
    _handleAudio(params) {
        const rtcNewPromise = new Promise((resolve, reject) => {
            const onClientError = (error) => {
                this.log.error(error);
                reject(new NexmoClientError(error));
            }
            const streamIndex = this.streamIndex;
            this.streamIndex++;
            this.rtcHelper.getUserAudio()
                .then((localStream) => {
                    if (this.application.activeStream.rtc_id) {
                        return onClientError(new NexmoClientError('error:media:already-connecting'));
                    }
                    const clientId = Utils.allocateUUID();
                    const pc_config = {
                        'iceTransportPolicy': 'all',
                        'bundlePolicy': 'balanced',
                        'rtcpMuxPolicy': 'require',
                        'iceCandidatePoolSize': '0'
                    };
                    if (this.application.session.config &amp;&amp; this.application.session.config.iceServers) {
                        pc_config.iceServers = this.application.session.config.iceServers
                    }
                    const pc = this.rtcHelper.createRTCPeerConnection(pc_config, {
                        optional: [{
                            'DtlsSrtpKeyAgreement': 'true'
                        }]
                    }, clientId);

                    pc.trace('conversation_id', this.parentConversation.id);
                    pc.trace('member_id', this.parentConversation.me.id);

                    if (this.application.session.config.callstats &amp;&amp; this.application.session.config.callstats.enabled) {
                        this._enableCallStats(pc);
                    }
                    this.pc = pc;
                    this.application.activeStream.pc = pc;
                    this.application.activeStream.localStream = localStream;
                    pc.ontrack = (evt) => {
                        this.application.activeStreams.push(evt.streams[0]);
                        resolve(evt.streams[0]);
                    };
                    pc.addStream(localStream);

                    pc.onnegotiationneeded = () => {
                        pc.createOffer().then((offer) => {
                            return pc.setLocalDescription(offer);
                        }).then(() => {

                            // Send the offer to the remote peer through the signaling server
                        }).catch(onClientError);
                    }

                    pc.oniceconnectionstatechange = (status) => {
                        switch (pc.iceConnectionState) {
                            //https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState
                            case 'disconnected':
                                this.log.warn('One or more transports is disconnected', pc.iceConnectionState);
                                break;
                            case 'failed':
                                onClientError(status);
                                this.log.warn('One or more transports has terminated unexpectedly or in an error', status);
                                break;
                            default:
                                this.log.debug('The ice connection status changed', pc.iceConnectionState);
                                break;
                        }
                    }
                    let gatheringTimer = null;
                    let rtc_sent = false;
                    pc.onicegatheringstatechange = () => {
                        const do_gatherDone = () => {
                            if (!this.pc) {
                                return;
                            }
                            const event_to_emit = {
                                type: 'rtc:new',
                                cid: this.parentConversation.id,
                                from: this.parentConversation.me.id,
                                body: {
                                    offer: this.pc.localDescription
                                }
                            }
                            if (params &amp;&amp; params.label) {
                                event_to_emit.label = params.label;
                            }
                            this.application.session.sendRequest(event_to_emit, (response) => {
                                if (response.type === 'rtc:new:success') {
                                    const rtc_id = response.body.rtc_id;
                                    this.application.activeStream.rtc_id = rtc_id;
                                    pc.trace('rtc_id', rtc_id);
                                    this.rtcObjects[rtc_id] = {
                                        rtc_id: rtc_id,
                                        pc: pc,
                                        localStream: localStream,
                                        type: 'audio',
                                        streamIndex: streamIndex
                                    };
                                    this.parentConversation.me.emit("media:stream:on", this.rtcObjects[rtc_id]);
                                } else {
                                    reject(new NexmoApiError(response));
                                }
                            });
                        };

                        switch (pc.iceGatheringState) {
                            case 'new':

                                this.log.debug('ice gathering new');
                                break;
                            case 'complete':
                                window.clearTimeout(gatheringTimer);
                                gatheringTimer = null;
                                if (!rtc_sent) {
                                    do_gatherDone();
                                }
                                this.log.debug('ice gathering complete');

                                break;
                            case 'gathering':
                                gatheringTimer = setTimeout(() => {
                                    do_gatherDone();
                                    rtc_sent = true;
                                }, 2000);
                                this.log.debug('ice gathering gathering');
                                break;
                        }
                    }
                })
                .then(() => {
                    // We want to be able to handle these events, for this  member, before they get propagated out
                    this.parentConversation.once('rtc:answer', 'media_module', (event) => {

                        if (!this.application.activeStream.rtc_id) {
                            this.log.warn("RTC: rtc:new hasn't been resolved yet");
                        } else if (this.application.activeStream.rtc_id !== event.body.rtc_id) {
                            this.log.warn("RTC: skipping  rtc answer for different rtc_id");
                            return;
                        }
                        if (!this.pc) {
                            this.log.warn('RTC: received an answer too late');
                            return;
                        }
                        this.pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: event.body.answer
                        }),
                            () => {
                                this.log.debug('remote description is set');
                            },
                            onClientError);
                    });
                    this._attachEndingEventHandlers();
                })
                .catch((error) => {
                    reject(new NexmoClientError(error));
                });
        });
        this.rtcNewPromises.push(rtcNewPromise);

        return rtcNewPromise;
    }

    _handleVideo(params) {
        return Promise.resolve()
            .then(() => {
                if (params.video) {
                    let direction = 'none';
                    let name = 'video';
                    let videoConstraints;
                    let audioConstraints;
                    if (params.video === Object(params.video)) {
                        direction = params.video.direction;
                        name = params.video.name || 'video';
                        videoConstraints = params.video.constraints;

                    } else {
                        direction = params.video;
                    }
                    if (params.audio) {
                        audioConstraints = params.audio.constraints;
                    }
                    switch (direction) {
                        case 'both':
                        case 'send_only':
                        case true:
                            return this.rtcHelper.getUserVideo(videoConstraints, audioConstraints).then((localStream) => {
                                return this._handleVideoSend(localStream, direction === 'send_only', 'video', name, params);
                            });
                        case 'receive_only':
                            this.log.debug('video - receive_only not implemented yet');
                            return Promise.reject(new NexmoApiError('Not implemented yet'));
                        case 'none':
                            break;
                        default:
                            if (direction === false) {
                                let rtcObjectWithType = this._findRtcObjectByType('video');
                                if (rtcObjectWithType) {
                                    return this._disableLeg(rtcObjectWithType.rtc_id);
                                }
                            }
                            break;
                    }
                } else {
                    return Promise.resolve();
                }
            }).then(() => {
                if (params.screenshare) {
                    let direction = false;
                    let name;
                    let options = { sources: ['screen', 'window', 'tab'] };
                    if (params.screenshare === Object(params.screenshare)) {
                        direction = params.screenshare.direction;
                        name = params.screenshare.name || 'screenshare';
                        options.sources = params.screenshare.sources || options.sources;
                        options.sourceId = params.screenshare.sourceId || '';
                    } else {
                        direction = params.screenshare;
                    }
                    switch (direction) {
                        case 'send_only':
                        case true:
                            return this.rtcHelper.getUserScreen(options).then((localStream) => {
                                return this._handleVideoSend(localStream, true, 'screenshare', name, params);
                            });
                        case 'none':
                            break;
                        default:
                            if (direction === false) {
                                let rtcObjectWithType = this._findRtcObjectByType('screenshare');
                                if (rtcObjectWithType) {
                                    return this._disableLeg(rtcObjectWithType.rtc_id);
                                }
                            }
                            break;
                    }
                } else {
                    Promise.resolve();
                }
            })
    }

    _emitEventsByRtcId(rtc_id) {
        this._eventsQueue.filter((event) => event.rtc_id === rtc_id)
            .forEach((event) => {
                event.func();
                event.ran = true;
            });
        this._eventsQueue = this._eventsQueue.filter((event) => event.ran === false);
    }

    _runWhenLegInitialized(rtc_id, func) {
        if (this.rtcObjects[rtc_id]) {
            func();
        } else {
            this._eventsQueue.push({
                rtc_id: rtc_id,
                func: func,
                ran: false
            })
        }
    }

    _handleVideoSend(localStream, isSendOnly, type, name, params) {
        const clientId = Utils.allocateUUID();
        const pc = this.rtcHelper.createRTCPeerConnection({
            'iceServers': this.application.session.config.iceServers,
            'iceTransportPolicy': 'all',
            'bundlePolicy': 'balanced',
            'rtcpMuxPolicy': 'require',
            'iceCandidatePoolSize': '0'
        }, {
                optional: [{
                    'DtlsSrtpKeyAgreement': 'true'
                }]
            }, clientId);

        pc.trace('conversation_id', this.parentConversation.id);
        pc.trace('member_id', this.parentConversation.me.id);

        if (this.application.session.config.callstats &amp;&amp; this.application.session.config.callstats.enabled) {
            this._enableCallStats(pc);
        }
        // We want to be able to handle these events, for this  member, before they get propagated out
        if (!this.listeningToRtcEvent) {
            this.parentConversation.on('rtc:answer', 'media_module', (event) => {
                let setRemoveDescriptionFunc =
                    () => {
                        this.rtcObjects[event.body.rtc_id].pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: event.body.answer
                        })).then(() => {
                            this.log.debug('remote description is set');
                        }).catch((e) => {
                            this.log.warn('set remote description failed with error', e);
                        });
                    };

                this._runWhenLegInitialized(event.body.rtc_id, setRemoveDescriptionFunc)
            });
        }

        if (!isSendOnly &amp;&amp; !this.listeningToRtcEvent) {
            this.parentConversation.on('rtc:offer', 'media_module', (event) => {
                let handleOfferFunc = () => {
                    this._handleNewOffer(params, event);
                };
                this._runWhenLegInitialized(event.body.leg_id, handleOfferFunc);
            });
            // this._attachEndingEventHandlers();
        }

        this.listeningToRtcEvent = true;
        pc.ontrack = (evt) => {
            this.log.debug('ontrack');
            this.application.activeStreams.push(evt.streams[0]);
        };

        pc.addStream(localStream);
        let streamIndex = this.streamIndex;
        this.streamIndex++;
        const p = new Promise((resolve, reject) => {
            pc.createOffer()
                .then((desc) => {
                    return pc.setLocalDescription(desc);
                })
                .then(() => {
                    const direction = isSendOnly ? 'send_only' : 'both';
                    const event_to_emit = {
                        type: 'rtc:new',
                        cid: this.parentConversation.id,
                        from: this.parentConversation.me.id,
                        body: {
                            offer: {
                                sdp: pc.localDescription.sdp
                            },
                            video: {
                                direction,
                                name
                            }
                        }
                    };
                    if (params &amp;&amp; params.label) {
                        event_to_emit.label = params.label;
                    }
                    this.application.session.sendRequest(event_to_emit, (response) => {
                        if (response.type === 'rtc:new:success') {
                            const rtc_id = response.body.rtc_id;
                            this.rtcObjects[rtc_id] = {
                                rtc_id: rtc_id,
                                pc: pc,
                                localStream: localStream,
                                type: type,
                                streamIndex: streamIndex
                            };
                            this._emitEventsByRtcId(rtc_id);
                            pc.trace('rtc_id', rtc_id);
                            if (type === 'screenshare') {
                                localStream.getVideoTracks()[0].onended = () => {
                                    this._disableLeg(rtc_id)
                                        .then(() => {
                                            this.parentConversation.me.emit("media:stream:off", streamIndex);
                                        })
                                        .catch(() => {
                                            this.parentConversation.me.emit("media:stream:off", streamIndex);
                                        })
                                };
                            }
                            resolve(rtc_id);
                        } else {
                            reject(new NexmoApiError(response));
                        }
                    });
                }).catch((e) => {
                    reject(new NexmoApiError(e));
                })
        });
        this.rtcNewPromises.push(p);
        this.parentConversation.me.emit("media:stream:on", {
            type: type,
            name: name,
            streamIndex: streamIndex,
            stream: localStream
        });
        const promisesArray = [];
        pc.onicecandidate = (event) => {
            p.then((rtc_id) => {
                const body = {};
                this._onIceCandidate(promisesArray, event, body, rtc_id);
            })
        };

        pc.oniceconnectionstatechange = (status) => {
            switch (pc.iceConnectionState) {
                //https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState
                case 'disconnected':
                    this.log.warn('One or more transports is disconnected', pc.iceConnectionState);
                    break;
                case 'failed':
                    this.log.warn('One or more transports has terminated unexpectedly or in an error', status);
                    break;
                default:
                    this.log.debug('The ice connection status changed', pc.iceConnectionState);
                    break;
            }
        }
        pc.onicegatheringstatechange = () => {
            switch (pc.iceGatheringState) {
                case 'new':
                    this.log.debug('ice gathering new');
                    break;
                case 'complete':
                    this.log.debug('ice gathering complete');
                    break;
                case 'gathering':
                    this.log.debug('ice gathering gathering');
                    break;
            }
        }
        this._attachEndingEventHandlers();
        this.log.debug('sending local stream');

        return p;
    }

    _sendIceRequest(body, rtc_id) {

        return new Promise((resolve, reject) => {
            const event_to_emit = {
                type: 'rtc:ice',
                cid: this.parentConversation.id,
                from: this.parentConversation.me.id,
                rtc_id: rtc_id,
                body: body
            }

            this.application.session.sendRequest(event_to_emit, (response) => {
                if (response.type === 'rtc:ice:success') {
                    resolve();
                } else {
                    reject(new NexmoApiError(response));
                }
            });
        })
    }

    _onIceCandidate(promiseArray, event, body, rtc_id) {

        const bodyToSend = body;

        if (event.candidate) {
            bodyToSend.candidates = event.candidate;
            this.log.debug('sending trickle candidates: ', bodyToSend);
            promiseArray.push(this._sendIceRequest(bodyToSend, rtc_id))
        } else {
            bodyToSend.candidates = {
                completed: true
            };
            return Promise.all(promiseArray)
                .then(this._sendIceRequest(bodyToSend, rtc_id))
                .then(() => {
                    this.log.debug('successfully sent trickle candidates', bodyToSend);
                })
                .catch(() => {
                    this.log.error('failed to send trickle candidates', bodyToSend);
                });
        }
    }

    _handleNewOffer(params, event) {
        const remoteMemberObject = {
            remote_member_id: event.body.member_id,
            remote_leg_id: event.body.member_leg_id,
            local_leg_id: event.body.leg_id,
            name: event.body.name,
            streamIndex: this.streamIndex
        };
        this.streamIndex++;

        const video_mute = event.body.media_settings &amp;&amp; event.body.media_settings.video ?
            event.body.media_settings.video.muted : false;
        const audio_mute = event.body.media_settings &amp;&amp; event.body.media_settings.audio ?
            event.body.media_settings.audio.muted : false;

        for (let member of this.parentConversation.members.values()) {
            const member_id = member.id;
            if (member_id === event.body.member_id) {
                remoteMemberObject.remote_member = this.parentConversation.members.get(member_id);
            }
        }

        this.parentConversation.remoteMembers.push(remoteMemberObject);
        this.log.debug('handle rtc:offer for member ' + remoteMemberObject.remote_member_id);

        const clientId = Utils.allocateUUID();
        remoteMemberObject.pc = this.rtcHelper.createRTCPeerConnection({
            'iceServers': this.application.session.config.iceServers,
            'iceTransportPolicy': 'all',
            'bundlePolicy': 'balanced',
            'rtcpMuxPolicy': 'require',
            'iceCandidatePoolSize': '0'
        }, {
                optional: [{
                    'DtlsSrtpKeyAgreement': 'true'
                }]
            }, clientId);

        if (this.application.session.config.callstats &amp;&amp; this.application.session.config.callstats.enabled) {
            this._enableCallStats(pc);
        }

        remoteMemberObject.pc.trace('conversation_id', this.parentConversation.id);
        remoteMemberObject.pc.trace('member_id', this.parentConversation.me.id);
        remoteMemberObject.pc.trace('rtc_id', remoteMemberObject.local_leg_id);
        remoteMemberObject.pc.trace('other_member_id', remoteMemberObject.remote_member_id);

        remoteMemberObject.pc.ontrack = (evt) => {
            if (remoteMemberObject.stream !== evt.streams[0]) {
                remoteMemberObject.stream = evt.streams[0];
                remoteMemberObject.remote_member.emit("media:stream:on", {
                    streamIndex: remoteMemberObject.streamIndex,
                    rtc_id: remoteMemberObject.local_leg_id,
                    remote_member_id: remoteMemberObject.remote_member_id,
                    name: remoteMemberObject.name,
                    stream: remoteMemberObject.stream,
                    video_mute: video_mute,
                    audio_mute: audio_mute
                });
            }
        };

        let p = Promise.resolve();
        const promisesArray = [];
        remoteMemberObject.pc.onicecandidate = (event) => {

            p = p.then(() => {
                const body = {
                    other_member_id: remoteMemberObject.remote_member_id,
                    leg_id: remoteMemberObject.remote_leg_id
                };
                this._onIceCandidate(promisesArray, event, body, remoteMemberObject.local_leg_id);
            })
        }

        remoteMemberObject.pc.oniceconnectionstatechange = (status) => {
            switch (remoteMemberObject.pc.iceConnectionState) {
                //https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState
                case 'disconnected':
                    this.log.warn('One or more transports is disconnected', remoteMemberObject.pc.iceConnectionState);
                    break;
                case 'failed':
                    this.log.warn('transports has terminated or failed for member ' + event.body.member_id, status);
                    break;
                default:
                    this.log.debug('The ice connection status changed for member ' + event.body.member_id, remoteMemberObject.pc.iceConnectionState);
                    break;
            }
        };
        remoteMemberObject.pc.onicegatheringstatechange = () => {
            switch (remoteMemberObject.pc.iceGatheringState) {
                case 'new':
                    this.log.debug('ice gathering new for member ' + event.body.member_id);
                    break;
                case 'complete':
                    this.log.debug('ice gathering complete for member ' + event.body.member_id);
                    break;
                case 'gathering':
                    this.log.debug('ice gathering gathering for member ' + event.body.member_id);
                    break;
            }
        };
        const rtcAnswerFunc = () => {
            remoteMemberObject.pc.setRemoteDescription(new RTCSessionDescription({
                type: 'offer',
                sdp: event.body.sdp
            }))
                .then(() => {
                    return remoteMemberObject.pc.createAnswer()
                })
                .then((answer) => {
                    return remoteMemberObject.pc.setLocalDescription(answer);
                })
                .then(() => {
                    const event_to_emit = {
                        type: 'rtc:answer',
                        cid: this.parentConversation.id,
                        rtc_id: remoteMemberObject.local_leg_id,
                        from: this.parentConversation.me.id,
                        body: {
                            other_member_id: remoteMemberObject.remote_member_id,
                            answer: remoteMemberObject.pc.localDescription.sdp,
                            leg_id: remoteMemberObject.remote_leg_id
                        }
                    };

                    if (params &amp;&amp; params.label) {
                        event_to_emit.label = params.label;
                    }

                    this.application.session.sendRequest(event_to_emit,
                        (response) => {
                            if (response.type === 'rtc:answer:success') {
                                this.log.debug('successfully set answer for member ' + remoteMemberObject.remote_member_id);
                            } else {
                                this.log.error(response.type + ': failed to set answer for member ' + remoteMemberObject.remote_member_id);
                            }
                        });
                });
        }

        this._runWhenLegInitialized(remoteMemberObject.local_leg_id, rtcAnswerFunc);
    }

    _handleMemberLeft(member_left) {
        const member_id = member_left.id;
        const member_legs = this.parentConversation.remoteMembers.filter((member) => {
            return member.remote_member_id === member_id
        });
        member_legs.forEach((member_leg) => {
            this._handleParticipantRtcTerminate({ body: { rtc_id: member_leg.remote_leg_id } });
        })
    }

    _handleParticipantRtcTerminate(event) {
        const member = this.parentConversation.remoteMembers.find((member) => {
            return member.remote_leg_id === event.body.rtc_id
        });

        if (!member) {
            this.log.error('rtc:terminate was sent with invalid member id');
            return;
        }

        this.parentConversation.remoteMembers = this.parentConversation.remoteMembers.filter((remoteMember) => {
            return remoteMember.remote_leg_id !== event.body.rtc_id
        });
        this._deleteMemberMedia(member);
        member.remote_member.emit("media:stream:off", {
            remote_member_id: member.remote_member_id,
            streamIndex: member.streamIndex
        });
    }

    _deleteMemberMedia(member) {
        this._closeStream(member.stream);
        member.pc.close();
    }

    _findRtcObjectByType(type) {
        return Object.values(this.rtcObjects)
            .find((rtcObject) => rtcObject.type === type);
    }

    update(params) {
        return new Promise((resolve, reject) => {
            this._validateUpdateParams(params)
                .then(() => {
                    if (params.video) {
                        const rtcObject = this._findRtcObjectByType('video');
                        if ((rtcObject &amp;&amp; params.video.direction) || (!rtcObject &amp;&amp; !params.video.direction)) {
                            return reject(new NexmoClientError('error:media:update:invalid'));
                        }
                    } else if (params.screenshare) {
                        const rtcObject = this._findRtcObjectByType('screenshare');
                        if ((rtcObject &amp;&amp; params.screenshare.direction) || (!rtcObject &amp;&amp; !params.screenshare.direction)) {
                            return reject(new NexmoClientError('error:media:update:invalid'));
                        }
                    }
                    return this._handleVideo(params).then(resolve).catch(reject);
                }).catch(err => reject(err));
        })
    }

    _validateUpdateParams(params) {
        return new Promise((resolve, reject) => {
            if (params &amp;&amp; (params.video || params.screenshare)) {
                if (params.video &amp;&amp; params.screenshare) {
                    return reject(new NexmoClientError('error:media:update:streams'));
                }
            } else {
                return reject(new NexmoClientError('error:media:update:unsupported'));
            }
            resolve();
        });
    }

    _closeStream(stream) {
        stream.getTracks().forEach((track) => {
            track.stop();
        });
    }

    _cleanConversationProperties() {
        return Promise.resolve().then(() => {
            if (this.pc) {
                this.pc.close();
            }
            if (this.parentConversation.remoteMembers) {
                this.parentConversation.remoteMembers.forEach((member) => {
                    member.remote_member.emit('media:stream:off', {
                        remote_member_id: member.remote_member_id,
                        streamIndex: member.streamIndex
                    });
                    this._deleteMemberMedia(member);
                });
            }

            // stop active stream
            if (this.application.activeStream.localStream) {
                this._closeStream(this.application.activeStream.localStream);
            }
            delete this.pc;
            this.application.activeStream = {};
            this.parentConversation.remoteMembers = [];
            this.parentConversation.releaseGroup('media_module');
            this.listeningToRtcEvent = false;
        });
    }

    _disableLeg(leg_id) {
        const csRequestPromise = new Promise((resolve, reject) => {
            this.application.session.sendRequest({
                type: 'rtc:terminate',
                cid: this.parentConversation.id,
                from: this.parentConversation.me.id,
                rtc_id: leg_id
            }, (response) => {
                if (response.type === 'rtc:terminate:success') {
                    resolve(response.type);
                } else {
                    //make sure we have cleaned the objects
                    reject(new NexmoApiError(response));
                }
            });
        });
        const closeResourcesPromise = Promise.resolve().then(() => {
            if (this.rtcObjects[leg_id].pc) this.rtcObjects[leg_id].pc.close();
            if (this.rtcObjects[leg_id].localStream) {
                this._closeStream(this.rtcObjects[leg_id].localStream);
            }
        });
        return Promise.all([csRequestPromise, closeResourcesPromise]).then(() => {
            this.parentConversation.me.emit("media:stream:off", this.rtcObjects[leg_id].streamIndex);
            delete this.rtcObjects[leg_id];
            return Promise.resolve('rtc:terminate:success')
        }).catch((error) => {
            return Promise.reject(error);
        });
    }

    _sendMuteRequest(rtc_id, type, callback) {
        let params = {
            rtc_id: rtc_id
        };
        let request = {
            type: type,
            cid: this.parentConversation.id,
            to: this.parentConversation.me.id,
            from: this.parentConversation.me.id,
            body: params
        };
        this.application.session.sendRequest(request, callback);
    }

    _enableMediaTracks(tracks, enabled) {
        tracks.forEach((mediaTrack) => {
            mediaTrack.enabled = enabled;
        });
    }

	/**
	 * Send a mute request with the rtc_id and enable/disable the tracks
	 * If the mute request fails revert the changes in the tracks
	 * @private
	 */
    _setMediaTracksAndMute(rtc_id, tracks, mute, mediaType, mediaSuccess) {
        this._enableMediaTracks(tracks, !mute);
        return new Promise((resolve, reject) => {
            this._sendMuteRequest(rtc_id, mediaType, (response) => {
                if (response.type === mediaSuccess) {
                    resolve(response.body);
                } else {
                    this._enableMediaTracks(tracks, mute);
                    reject(new NexmoApiError(response));
                }
            })
        })
    }

	/**
	 * Wait for all the rtc:new requests to be done.
	 * Even if some of them fail resolve the promise and log a warn
	 * @private
	 */
    _waitAllRtcNewAreCompleted() {
        return Promise.all(this.rtcNewPromises)
            .catch(() => {
                this.log.warn('Some of the enable requests failed.');
            });
    }

	/**
	 * Mute our member
	 *
	 * @param {boolean} [mute=false] true for mute, false for unmute
	 * @param {boolean} [audio=true] true for audio stream - relevant only in video conversation
	 * @param {boolean} [video=false] true for video stream - relevant only in video conversation
	 * @param {number} [streamIndex] stream id to set - if it's not set all streams will be muted
	 * @example &lt;caption>Mute audio stream in non video conversation&lt;/caption>
	 * media.mute(true)
	 * @example &lt;caption>Mute audio and video streams in video conversation&lt;/caption>
	 * media.mute(true, true, true, 0)
	 * @example &lt;caption>Mute only video in video conversation&lt;/caption>
	 * media.mute(true, false, true, 0)
	 */
    mute(mute = false, audio = true, video = false, streamIndex) {
        const state = mute ? 'on' : 'off';
        const audioType = 'audio:mute:' + state;
        const videoType = 'video:mute:' + state;
        const audioSuccess = audioType + ':success';
        const videoSuccess = videoType + ':success';
        let promises = [];

        return this._waitAllRtcNewAreCompleted()
            .then(() => {
                let muteObjects = {};
                if (streamIndex != null) {
                    muteObjects[0] = Object.values(this.rtcObjects).find((rtcObj => rtcObj.streamIndex === streamIndex));
                    if (!muteObjects[0]) {
                        throw new NexmoClientError('error:media:stream:not-found');
                    }
                } else {
                    muteObjects = this.rtcObjects;
                }
                Object.values(muteObjects).forEach(rtcObject => {
                    if (audio) {
                        const audioTracks = rtcObject.localStream.getAudioTracks();
                        const audioPromise = this._setMediaTracksAndMute(rtcObject.rtc_id, audioTracks, mute, audioType, audioSuccess);
                        promises.push(audioPromise);
                    }

                    if (video) {
                        const videoTracks = rtcObject.localStream.getVideoTracks();
                        const videoPromise = this._setMediaTracksAndMute(rtcObject.rtc_id, videoTracks, mute, videoType, videoSuccess);
                        promises.push(videoPromise);
                    }
                });
                return Promise.all(promises);
            });
    }

    /**
     * Earmuff our member
     *
     * @param {boolean} [params]
     *
     * @returns {Promise}
     * @private
     */
    earmuff(earmuff) {
        return new Promise((resolve, reject) => {
            if (this.me === null) {
                reject(new NexmoClientError("error:self"));
            } else {
                let type = 'audio:earmuff:off';
                if (earmuff) {
                    type = 'audio:earmuff:on';
                }
                this.application.session.sendRequest({
                    type: type,
                    cid: this.parentConversation.id,
                    to: this.parentConversation.me.id
                }, (response) => {
                    const onoff = (earmuff) ? 'on' : 'off';
                    if (response.type === 'audio:earmuff:' + onoff + ':success') {
                        resolve(response.body);
                    } else {
                        reject(new NexmoApiError(response));
                    }
                });
            }
        });
    }

    /**
       * Enable media participation in the conversation for this application (requires WebRTC)
       * @param {object} params - rtc params
       * @param {string} params.label - Label is an application defined tag, eg. ‘fullscreen’
       * @param {object} [params.audio=true] - audio enablement mode. possible values "both", "send_only", "receive_only", "none", true or false
       * * &lt;!-- the following line should be added when deploying video to prod.
       * @param {object} [params.video=false] - video enablement mode. possible values "both", "send_only", "receive_only", "none", true or false
       * @param {object} [params.video={direction: 'some_direction', constraints: constraints_object}] - video enablement mode.
       * possible values for direction "both", "send_only", "receive_only", "none", true or false
       * @param {object} [params.screenshare=false] -screen sharing enablement mode. possible values "send_only", "none", true or false
       * @param {object} [params.screenshare={direction: 'some_direction'}] - screen sharing enablement mode. possible values for direction "send_only", "none", true or false  -->
       * @returns {Promise&lt;MediaStream>}
       * @example &lt;caption>Enable media in this conversation&lt;/caption>
       * function enable() {
       *   conversation.media.enable()
       *      .then((stream) => {
                  const media = document.createElement("audio");
                  const source = document.createElement("source");
                  const media_div = document.createElement("div");

                  media.appendChild(source);
                  media_div.appendChild(media);
                  document.insertBefore(media_div);

                  // Older browsers may not have srcObject
                  if ("srcObject" in media) {
                      media.srcObject = stream;
                  } else {
                      // Avoid using this in new browsers, as it is going away.
                      media.src = window.URL.createObjectURL(stream);
                  }

                  media.onloadedmetadata = (e) => {
                      media.play();
                  };
          *
       * 		 }).catch((error) => {
       *           console.log(error);
       *       });
       * }
       *
       *
       *
       **/
    enable(params) {
        return new Promise((resolve, reject) => {
            const onClientError = (error) => {
                this.log.error(error);
                reject(new NexmoClientError(error));
            }
            if (this.parentConversation.me === null) {
                reject(new NexmoClientError('error:self'));
            } else {
                if (params &amp;&amp; this.parentConversation.is_video_conversation) {
                    return this._handleVideo(params).catch(reject)
                        .then(() => {
                            const types = ['video', 'screenshare'];
                            let disablePromises = [];
                            types.forEach((type) => {
                                if (!params[type]) {
                                    let rtcObjectWithType = this._findRtcObjectByType(type);
                                    if (rtcObjectWithType) {
                                        disablePromises.push(this._disableLeg(rtcObjectWithType.rtc_id));
                                    }
                                }
                            });
                            return Promise.all(disablePromises)
                                .then(resolve)
                                .catch(reject);
                        })
                }
                if (this.application.activeStream.rtc_id) {
                    return onClientError(new NexmoClientError('error:media:already-connecting'));
                }
                // this needs to happen soon before we use pc.trace
                // ps.trace is injected in rtcstats module
                if (this.rtcstats.emit_events) {
                    this._initStatsEvents();
                }
                return this._handleAudio(params)
                    .then((result) => resolve(result))
                    .catch((error) => reject(error));
            }
        });
    }

    /**
     * Disable media particiaption in the conversation for this application
     * if RtcStats MOS is enabled, a final report will be available in
     * ConversationClient#rtcstats:report
     * @returns {Promise}
     * @example
     *
     * function disable() {
     *   conversation.media.disable()
     *      .then((response) => {
     *       }).catch((error) => {
     *           console.log(error);
     *       });
     * }
     *
     **/
    disable() {
        let promises = [];
        promises.push(this._cleanConversationProperties());

        for (const leg_id in this.rtcObjects) {
            promises.push(this._disableLeg(leg_id));
        }
        return Promise.all(promises);
    }

    /**
     * Play a voice text in a conversation
     * @param {object} params
     * @param {string} params.text - the text to say in the conversation
     * @param {string} params.voice_name -
     * @param {number} params.level - [0] -
     * @param {boolean} params.queue -
     * @param {boolean} params.loop -
     *
     * @returns {Promise&lt;Event>}
     * @example
     *   conversation.media.say({text:'hi'})
     **/
    sayText(params) {
        return new Promise((resolve, reject) => {
            const msg = {
                type: 'audio:say',
                cid: this.parentConversation.id,
                body: {
                    text: params.text,
                    voice_name: params.voice_name || 'Amy',
                    level: params.level || 1,
                    queue: params.queue || true,
                    loop: params.loop || 1,
                    ssml: params.ssml || false
                }
            };
            this.application.session.sendRequest(msg, (response) => {
                if (response.type === 'audio:say:success') {
                    msg.id = response.body.id;
                    resolve(new Event(this.parentConversation, response));
                } else {
                    reject(new NexmoApiError(response));
                }
            });
        });
    }

    /**
     * Record the audio stream in a conversation
     * @param {object} params
     * @param {string} params.format = (mp3, wav, ogg)
     * @param {boolean} params.streamed -
     * @param {number} params.validity_time -
     * @param {boolean} params.beep_start -
     * @param {boolean} params.beep_stop -~
     * @param {boolean} params.detect_speech -
     *
     * @returns {Promise&lt;Recording>}
     * @example
     *   conversation.audio.record()
     */
    record(params) {
        return new Promise((resolve, reject) => {
            const msg = {
                type: 'audio:record',
                cid: this.id,
                body: {
                    format: params.format,
                    destination_url: params.destination_url,
                    streamed: params.streamed,
                    validity_time: params.validity_time,
                    beep_start: params.beep_start,
                    beep_stop: params.beep_stop,
                    detect_speech: params.detect_speech
                }
            };
            this.application.session.sendRequest(msg, (response) => {
                if (response.type === 'audio:record:success') {
                    msg.id = response.body.id;
                    resolve(new Recording(this.parentConversation, response));
                } else {
                    reject(new NexmoApiError(response));
                }
            });
        });
    }

    /**
     * Download the recoding file
     * @param {string} url the recording url coming in the recording event
     * @returns {Promise&lt;Event>}
     */
    fetchRecording(url) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            Utils.getToken().then(token => {
                xhr.open("GET", url);
                xhr.setRequestHeader("Authorization", "Bearer " + token);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.responseType = 'blob';
                xhr.onload = () => {
                    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
                        const blob = new Blob([xhr.response], {
                            type: 'audio/ogg'
                        });
                        resolve(URL.createObjectUrl(blob));
                    } else {
                        reject(new NexmoClientError("error:fetch-recording"));
                    }
                };
                xhr.send();
            });
        });
    }

    /**
     * Play an audio stream in a conversation
     * @returns {Promise&lt;Event>}
     */
    playStream(params) {
        return new Promise((resolve, reject) => {
            const msg = {
                type: 'audio:play',
                cid: this.parentConversation.id,
                body: params
            };
            this.application.session.sendRequest(msg, (response) => {
                if (response.type === 'audio:play:success') {
                    msg.id = response.body.id;
                    resolve(new Event(this.parentConversation, response));
                } else {
                    reject(new NexmoApiError(response));
                }
            });
        });
    }

    /**
     * Send start ringing event
     * @returns {Promise&lt;Event>}
     * @example
     * Send ringing event
     * function startRinging() {
     *   conversation.media.startRinging()
     *      .then((response) => {
     *       }).catch((error) => {
     *           console.log(error);
     *       });
     * }
     *
     * conversation.on('audio:ringing:start', (data) => {
     * console.log("ringing");
     * });
     */
    startRinging() {
        return new Promise((resolve, reject) => {
            const msg = {
                type: 'audio:ringing:start',
                cid: this.parentConversation.id,
                from: this.parentConversation.me.id,
                body: {}
            };
            this.application.session.sendRequest(msg, (response) => {
                if (response.type === 'audio:ringing:start:success') {
                    resolve(new Event(this.parentConversation, response));
                } else {
                    reject(new NexmoApiError(response));
                }
            });
        });
    }

    /**
     * Send stop ringing event
     * @returns {Promise&lt;Event>}
     * @example
     * Send ringing event
     * function stopRinging() {
     *   conversation.media.stopRinging()
     *      .then(function(response) {
     *       }).catch(function(error) {
     *           console.log(error);
     *       });
     * }
     *
     * conversation.on('audio:ringing:stop', function(data)){
     * console.log("ringing stopped");
     * }
     */
    stopRinging() {
        return new Promise((resolve, reject) => {
            const msg = {
                type: 'audio:ringing:stop',
                cid: this.parentConversation.id,
                from: this.parentConversation.me.id,
                body: {}
            };
            this.application.session.sendRequest(msg, (response) => {
                if (response.type === 'audio:ringing:stop:success') {
                    resolve(new Event(this.parentConversation, response));
                } else {
                    reject(new NexmoApiError(response));
                }
            });
        });
    }
}

module.exports = Media;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Application.html">Application</a></li><li><a href="Call.html">Call</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationClient.html">ConversationClient</a></li><li><a href="Event.html">Event</a></li><li><a href="ImageEvent.html">ImageEvent</a></li><li><a href="Media.html">Media</a></li><li><a href="Member.html">Member</a></li><li><a href="Recording.html">Recording</a></li><li><a href="TextEvent.html">TextEvent</a></li></ul><h3>Events</h3><ul><li><a href="Application.html#event:call:status:changed">call:status:changed</a></li><li><a href="Application.html#event:NXM-errors">NXM-errors</a></li><li><a href="Application.html#event:member:call">member:call</a></li><li><a href="Application.html#event:member:invited">member:invited</a></li><li><a href="Application.html#event:member:joined">member:joined</a></li><li><a href="Application.html#event:rtcstats:report">rtcstats:report</a></li><li><a href="Application.html#event:sync:progress">sync:progress</a></li><li><a href="Call.html#event:member:call:state">member:call:state</a></li><li><a href="Conversation.html#event:audio:mute:off">audio:mute:off</a></li><li><a href="Conversation.html#event:audio:mute:on">audio:mute:on</a></li><li><a href="Conversation.html#event:event:delete">delete</a></li><li><a href="Conversation.html#event:image">image</a></li><li><a href="Conversation.html#event:text">text</a></li><li><a href="Conversation.html#event:image:seen">image:seen</a></li><li><a href="Conversation.html#event:member:invited">member:invited</a></li><li><a href="Conversation.html#event:member:joined">member:joined</a></li><li><a href="Conversation.html#event:member:left">member:left</a></li><li><a href="Conversation.html#event:member:media">member:media</a></li><li><a href="Conversation.html#event:text:seen">text:seen</a></li><li><a href="Conversation.html#event:text:typing:off">text:typing:off</a></li><li><a href="Conversation.html#event:text:typing:on">text:typing:on</a></li><li><a href="ConversationClient.html#event:connecting">connecting</a></li><li><a href="ConversationClient.html#event:disconnect">disconnect</a></li><li><a href="ConversationClient.html#event:error">error</a></li><li><a href="ConversationClient.html#event:ready">ready</a></li><li><a href="ConversationClient.html#event:reconnect">reconnect</a></li><li><a href="ConversationClient.html#event:reconnecting">reconnecting</a></li><li><a href="Member.html#event:media:stream:on">media:stream:on</a></li></ul><h3>Global</h3><ul><li><a href="global.html#NexmoApiError">NexmoApiError</a></li><li><a href="global.html#NexmoClientError">NexmoClientError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Feb 01 2019 11:02:45 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
